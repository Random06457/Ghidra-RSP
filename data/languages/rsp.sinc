macro clamp_signed(dst, src) {
    local tmp:2 = src;
    if (tmp s>= -32768) goto <L1>;
        tmp = -32768;
    <L1>
    if (tmp s<= 32767) goto <L2>;
        tmp = 32767;
    <L2>
    dst = tmp;
}

macro get_j_from_i(j, i, e)
{
    # todo: what happens if it's 1?
    if (e != 0 && e != 1) goto <L1>;
        j = i;
        goto <END>;
    <L1>
    if ((e & 0b1110) != 0b0010) goto <L2>;
        j = (e & 0b0001) + (i & 0b1110);
        goto <END>;
    <L2>
    if ((e & 0b1100) != 0b0100) goto <L3>;
        j = (e & 0b0011) + (i & 0b1100);
        goto <END>;
    <L3>
    if ((e & 0b1000) != 0b1000) goto <END>;
        j = (e & 0b0111);

    <END>
}

macro vco_set_notequ(i, x) {
    local x2:2 = x:2;
    local vco_mask:2 = 1 << (i + 8);
    local to_or:2 = x2 << (i + 8);
    VCO = (VCO & ~vco_mask) | to_or;
}

macro vco_set_carry(i, x) {
    local x2:2 = trunc(x);
    local vco_mask:2 = 1 << i;
    local to_or:2 = x2 << i;
    VCO = (VCO & ~vco_mask) | to_or;
}


# Coprocessor Computational insturction

# Multiply

:vmulf is prime=0x12 & fct=0b000000 unimpl
:vmacf is prime=0x12 & fct=0b001000 unimpl
:vmulu is prime=0x12 & fct=0b000001 unimpl
:vmacu is prime=0x12 & fct=0b001001 unimpl
:vrndp is prime=0x12 & fct=0b000010 unimpl
:vrndn is prime=0x12 & fct=0b001010 unimpl
:vmulq is prime=0x12 & fct=0b000011 unimpl
:vmacq is prime=0x12 & fct=0b001011 unimpl
:vmudl is prime=0x12 & fct=0b000100 unimpl
:vmadl is prime=0x12 & fct=0b001100 unimpl
:vmudm is prime=0x12 & fct=0b000101 unimpl
:vmadm is prime=0x12 & fct=0b001101 unimpl
macro vmudn_i(acc, d, s, t) {
    local tmp:4 = (sext(s) * sext(t));
    acc[0,32] = tmp;
    clamp_signed(d, acc[0,16]);
}
:vmudn vd, vs, vt[e] is prime=0x12 & bit25=1 & fct=0b000110 & vd & vs & vt & e {
    vmudn_i(acc0, vd[0,16], vs[0,16], vt[0,16]);
    vmudn_i(acc1, vd[16,16], vs[16,16], vt[16,16]);
    vmudn_i(acc2, vd[32,16], vs[32,16], vt[32,16]);
    vmudn_i(acc3, vd[48,16], vs[48,16], vt[48,16]);
    vmudn_i(acc4, vd[64,16], vs[64,16], vt[64,16]);
    vmudn_i(acc5, vd[80,16], vs[80,16], vt[80,16]);
    vmudn_i(acc6, vd[96,16], vs[96,16], vt[96,16]);
    vmudn_i(acc7, vd[112,16], vs[112,16], vt[112,16]);
}

:vmadn is prime=0x12 & fct=0b001110 unimpl
macro vmuldh_i(acc, d, s, t) {
    local tmp:4 = (sext(s) * sext(t));
    acc[0,32] = tmp << 16;
    clamp_signed(d, acc[16,16]);
}
:vmudh vd, vs, vt[e] is prime=0x12 & bit25=1 & fct=0b000111 & vd & vs & vt & e {
    vmuldh_i(acc0, vd[0,16], vs[0,16], vt[0,16]);
    vmuldh_i(acc1, vd[16,16], vs[16,16], vt[16,16]);
    vmuldh_i(acc2, vd[32,16], vs[32,16], vt[32,16]);
    vmuldh_i(acc3, vd[48,16], vs[48,16], vt[48,16]);
    vmuldh_i(acc4, vd[64,16], vs[64,16], vt[64,16]);
    vmuldh_i(acc5, vd[80,16], vs[80,16], vt[80,16]);
    vmuldh_i(acc6, vd[96,16], vs[96,16], vt[96,16]);
    vmuldh_i(acc7, vd[112,16], vs[112,16], vt[112,16]);
}
:vmadh is prime=0x12 & fct=0b001111 unimpl

# Add

macro vadd_i(i, vd, vs, vt, e) {
    local j:1;
    get_j_from_i(j, i, e);

    local d_addr:4 = &vd + zext(i) * 2;
    local s_addr:4 = &vs + zext(i) * 2;
    local t_addr:4 = &vt + zext(j) * 2;
    local a_addr:4 = &acc0 + zext(i) * 6;

    # todo: + VC0
    local res:4 = zext(*[register]:2 s_addr) + zext(*[register]:2 t_addr) + zext((VCO >> i) & 1);
    *[register]:2 a_addr = res[0,16];
    clamp_signed(*[register]:2 d_addr, res[0,16]);

    i = i + 1;
}
:vadd vd, vs, vt[e] is prime=0x12 & fct=0b010000 & vd & vs & vt & e {
    local i:1 = 0;
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    vadd_i(i, vd, vs, vt, e:1);
    VCO = 0;
}
:vsub is prime=0x12 & fct=0b010001 unimpl
:vabs is prime=0x12 & fct=0b010011 unimpl

macro vaddc_i(i, vd, vs, vt, e) {
    local j:1;
    get_j_from_i(j, i, e);

    local d_addr:4 = &vd + zext(i) * 2;
    local s_addr:4 = &vs + zext(i) * 2;
    local t_addr:4 = &vt + zext(j) * 2;
    local a_addr:4 = &acc0 + zext(i) * 6;

    local res:4 = zext(*[register]:2 s_addr) + zext(*[register]:2 t_addr);
    *[register]:2 a_addr = res[0,16];
    *[register]:2 d_addr = res[0,16];
    vco_set_carry(i, res[16,1]);
    vco_set_notequ(i, 0:1);

    i = i + 1;
}

:vaddc vd, vs, vt[e] is prime=0x12 & fct=0b010100 & vd & vs & vt & e {
    local i:1 = 0;
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
    vaddc_i(i, vd, vs, vt, e:1);
}
:vsubc is prime=0x12 & fct=0b010101 unimpl
:vsar is prime=0x12 & fct=0b011101 unimpl


# Select
:vlt is prime=0x12 & fct=0b100000 unimpl
:veq is prime=0x12 & fct=0b100001 unimpl
:vne is prime=0x12 & fct=0b100010 unimpl
:vge is prime=0x12 & fct=0b100011 unimpl
:vcl is prime=0x12 & fct=0b100100 unimpl
:vch is prime=0x12 & fct=0b100101 unimpl
:vcr is prime=0x12 & fct=0b100110 unimpl
:vmrg is prime=0x12 & fct=0b100111 unimpl


# Logical
:vand vd, vs, vt[e] is prime=0x12 & fct=0b101000 & vd & vs & vt & e unimpl
:vnand vd, vs, vt[e] is prime=0x12 & fct=0b101001 & vd & vs & vt & e unimpl
:vor vd, vs, vt[e] is prime=0x12 & fct=0b101010 & vd & vs & vt & e unimpl
:vnor vd, vs, vt[e] is prime=0x12 & fct=0b101011 & vd & vs & vt & e unimpl

macro vxor_i(i, vd, vs, vt, e) {
    local j:1;
    get_j_from_i(j, i, e);

    local d_addr:4 = &vd + zext(i) * 2;
    local s_addr:4 = &vs + zext(i) * 2;
    local t_addr:4 = &vt + zext(j) * 2;
    local a_addr:4 = &acc0 + zext(i) * 6;

    local res:4 = zext(*[register]:2 s_addr) + zext(*[register]:2 t_addr);
    *[register]:2 a_addr = res[0,16];
    *[register]:2 d_addr = res[0,16];
    vco_set_carry(i, res[16,1]);
    vco_set_notequ(i, 0:1);

    i = i + 1;
}
:vxor vd, vs, vt[e] is prime=0x12 & fct=0b101100 & vd & vs & vt & e {
    local i:1 = 0;
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
    vxor_i(i, vd, vs, vt, e:1);
}
:vvxor vd, vs, vt[e] is prime=0x12 & fct=0b101101 & vd & vs & vt & e unimpl


# Divide
:vrcp is prime=0x12 & fct=0b110000 unimpl
:vrcpl is prime=0x12 & fct=0b110001 unimpl
:vrcph is prime=0x12 & fct=0b110010 unimpl
:vmov is prime=0x12 & fct=0b110011 unimpl
:vrsq is prime=0x12 & fct=0b110100 unimpl
:vrsql is prime=0x12 & fct=0b110101 unimpl
:vrsqh is prime=0x12 & fct=0b110110 unimpl
:vnop is prime=0x12 & fct=0b110111 unimpl


# LWC2 / SWC2

:lbv vt[element], OFF06_BASE is prime=0b110010 & cop2lsop=0b00000 & vt & element & OFF06_BASE {
    addr:4 = &vt + element;
    *[register]:1 addr = *[ram] OFF06_BASE;
}
:sbv vt[element], OFF06_BASE is prime=0b111010 & cop2lsop=0b00000 & vt & element & OFF06_BASE {
    addr:4 = &vt + element;
    *[ram]:1 OFF06_BASE = *[register] addr;
}

:lsv vt[element], OFF06L1_BASE is prime=0b110010 & cop2lsop=0b00001 & vt & element & OFF06L1_BASE {
    addr:4 = &vt + element;
    *[register]:2 addr = *[ram] OFF06L1_BASE;
}
:ssv vt[element], OFF06L1_BASE is prime=0b111010 & cop2lsop=0b00001 & vt & element & OFF06L1_BASE {
    addr:4 = &vt + element;
    *[ram]:2 OFF06L1_BASE = *[register] addr;
}

:llv vt[element], OFF06L2_BASE is prime=0b110010 & cop2lsop=0b00010 & vt & element & OFF06L2_BASE {
    addr:4 = &vt + element;
    *[register]:4 addr = *[ram] OFF06L2_BASE;
}
:slv vt[element], OFF06L2_BASE is prime=0b111010 & cop2lsop=0b00010 & vt & element & OFF06L2_BASE {
    addr:4 = &vt + element;
    *[ram]:4 OFF06L2_BASE = *[register] addr;
}

:ldv vt[element], OFF06L3_BASE is prime=0b110010 & cop2lsop=0b00011 & vt & element & OFF06L3_BASE {
    addr:4 = &vt + element;
    *[register]:8 addr = *[ram] OFF06L3_BASE;
}
:sdv vt[element], OFF06L3_BASE is prime=0b111010 & cop2lsop=0b00011 & vt & element & OFF06L3_BASE {
    addr:4 = &vt + element;
    *[ram]:8 OFF06L3_BASE = *[register] addr;
}

:lqv vt[element], OFF06L4_BASE is prime=0b110010 & cop2lsop=0b00100 & vt & element & OFF06L4_BASE {
    addr:4 = &vt + element;
    *[register]:16 addr = *[ram] OFF06L4_BASE;
}
:sqv vt[element], OFF06L4_BASE is prime=0b111010 & cop2lsop=0b00100 & vt & element & OFF06L4_BASE {
    addr:4 = &vt + element;
    *[ram]:16 OFF06L4_BASE = *[register] addr;
}


:lrv vt[element], OFF06L4_BASE is prime=0b110010 & cop2lsop=0b00101 & vt & element & OFF06L4_BASE unimpl
:srv vt[element], OFF06L4_BASE is prime=0b111010 & cop2lsop=0b00101 & vt & element & OFF06L4_BASE unimpl

:lpv vt[element], OFF06L3_BASE is prime=0b110010 & cop2lsop=0b00110 & vt & element & OFF06L3_BASE unimpl
:spv vt[element], OFF06L3_BASE is prime=0b111010 & cop2lsop=0b00110 & vt & element & OFF06L3_BASE unimpl

:luv vt[element], OFF06L3_BASE is prime=0b110010 & cop2lsop=0b00111 & vt & element & OFF06L3_BASE unimpl
:suv vt[element], OFF06L3_BASE is prime=0b111010 & cop2lsop=0b00111 & vt & element & OFF06L3_BASE unimpl

:lhv vt[element], OFF06L4_BASE is prime=0b110010 & cop2lsop=0b01000 & vt & element & OFF06L4_BASE  unimpl
:shv vt[element], OFF06L4_BASE is prime=0b111010 & cop2lsop=0b01000 & vt & element & OFF06L4_BASE  unimpl

:lfv vt[element], OFF06L4_BASE is prime=0b110010 & cop2lsop=0b01001 & vt & element & OFF06L4_BASE  unimpl
:sfv vt[element], OFF06L4_BASE is prime=0b111010 & cop2lsop=0b01001 & vt & element & OFF06L4_BASE  unimpl

:ltv vt[element], OFF06L4_BASE is prime=0b110010 & cop2lsop=0b01011 & vt & element & OFF06L4_BASE  unimpl
:stv vt[element], OFF06L4_BASE is prime=0b111010 & cop2lsop=0b01011 & vt & element & OFF06L4_BASE  unimpl

:mtc2 rt, vs[element] is prime=0x12 & copop=4 & rt & vs & element {
    local addr:4 = &vs + element;
    *[register]:2 addr = rt;
}
